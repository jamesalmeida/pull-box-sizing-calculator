<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pull Box Sizing Calculator with Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        canvas { display: block; margin-bottom: 20px; max-width: 100%; height: auto; }
        .hidden { display: none; }
        .warning {
            display: none;
            background-color: #fff3f3;
            border: 1px solid #f87171;
            color: #dc2626;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            margin-top: 0.5rem;
        }
        .pulls-list {
            display: block; /* Default to mobile view */
        }
        .pull-item {
            border-bottom: 1px solid #e5e7eb;
            padding: 0.5rem 0;
        }
        .pull-item div {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }
        .pull-item div:last-child {
            margin-bottom: 0;
        }
        .conductor-mobile {
            display: none; /* Hide Conductor Size by default on mobile */
        }
        .has-rear .conductor-mobile {
            display: flex; /* Show if rear pull exists */
        }
        #pullsTable {
            display: none; /* Hidden by default, shown on desktop */
        }
        @media (min-width: 768px) {
            .pulls-list {
                display: none; /* Hide mobile list on desktop */
            }
            #pullsTable {
                display: table; /* Show table on desktop */
            }
            .container {
                padding: 1rem; /* Restore padding for desktop */
            }
            .bg-white {
                padding: 1.5rem; /* Restore padding for content boxes */
            }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto p-4 max-w-5xl">
        <h1 class="text-3xl font-bold text-center mb-6">Pull Box Sizing Calculator with Visualization</h1>
        
        <!-- Input Form -->
        <div class="bg-white p-6 rounded-lg shadow-md mb-6">
            <h2 class="text-xl font-semibold mb-4">Add Pull</h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                    <label for="entrySide" class="block text-sm font-medium">Entry Side</label>
                    <select id="entrySide" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm" onchange="toggleConductorSize()">
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                        <option value="top">Top</option>
                        <option value="bottom">Bottom</option>
                        <option value="rear">Rear</option>
                    </select>
                </div>
                <div>
                    <label for="exitSide" class="block text-sm font-medium">Exit Side</label>
                    <select id="exitSide" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm" onchange="toggleConductorSize()">
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                        <option value="top">Top</option>
                        <option value="bottom">Bottom</option>
                        <option value="rear">Rear</option>
                    </select>
                </div>
                <div>
                    <label for="conduitSize" class="block text-sm font-medium">Conduit Size (inches)</label>
                    <select id="conduitSize" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm">
                        <option value="0.5">1/2"</option>
                        <option value="0.75">3/4"</option>
                        <option value="1">1"</option>
                        <option value="1.25">1-1/4"</option>
                        <option value="1.5">1-1/2"</option>
                        <option value="2">2"</option>
                        <option value="2.5">2-1/2"</option>
                        <option value="3">3"</option>
                        <option value="3.5">3-1/2"</option>
                        <option value="4">4"</option>
                        <option value="5">5"</option>
                        <option value="6">6"</option>
                    </select>
                </div>
                <div id="conductorSizeContainer">
                    <label for="conductorSize" class="block text-sm font-medium">Conductor Size (AWG/kcmil)</label>
                    <select id="conductorSize" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm">
                        <option value="16">16 AWG</option>
                        <option value="14">14 AWG</option>
                        <option value="12">12 AWG</option>
                        <option value="10">10 AWG</option>
                        <option value="8">8 AWG</option>
                        <option value="6">6 AWG</option>
                        <option value="4">4 AWG</option>
                        <option value="3">3 AWG</option>
                        <option value="2">2 AWG</option>
                        <option value="1">1 AWG</option>
                        <option value="1/0">1/0 AWG</option>
                        <option value="2/0">2/0 AWG</option>
                        <option value="3/0">3/0 AWG</option>
                        <option value="4/0">4/0 AWG</option>
                        <option value="250">250 kcmil</option>
                        <option value="300">300 kcmil</option>
                        <option value="350">350 kcmil</option>
                        <option value="400">400 kcmil</option>
                        <option value="500">500 kcmil</option>
                        <option value="600">600 kcmil</option>
                        <option value="750">750 kcmil</option>
                        <option value="900">900 kcmil</option>
                        <option value="1000">1000 kcmil</option>
                        <option value="1250">1250 kcmil</option>
                        <option value="1500">1500 kcmil</option>
                        <option value="1750">1750 kcmil</option>
                        <option value="2000">2000 kcmil</option>
                    </select>
                </div>
            </div>
            <div class="mt-4 flex gap-2">
                <button onclick="addPull()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Add Pull</button>
                <button onclick="clearAllPulls()" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">Clear All Pulls</button>
            </div>
        </div>

        <!-- Visualization and Pulls Table -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <!-- Visualization -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-4">Pull Box Visualization</h2>
                <div id="view-controls" class="mb-4">
                    <div class="flex gap-2 flex-wrap">
                        <button id="toggleView" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Switch to Orthogonal View</button>
                        <button id="toggleInteraction" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">Switch to Rotate Mode</button>
                        <button id="toggleWireframe" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700">Switch to Wireframe</button>
                    </div>
                </div>
                <div id="canvas-holder" class="overflow-auto">
                    <!-- Canvas will be created here by p5.js -->
                </div>
            </div>
            <!-- Pulls Table -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-4">Pulls List</h2>
                <div class="overflow-x-auto">
                    <table id="pullsTable" class="w-full border-collapse min-w-full">
                        <thead>
                            <tr class="bg-gray-200">
                                <th class="border p-2">Pull #</th>
                                <th class="border p-2">Entry Side</th>
                                <th class="border p-2">Exit Side</th>
                                <th class="border p-2">Conduit Size (in)</th>
                                <th class="border p-2">Conductor Size</th>
                                <th class="border p-2">Action</th>
                            </tr>
                        </thead>
                        <tbody id="pullsBody"></tbody>
                    </table>
                    <div class="pulls-list">
                        <!-- Mobile stacked list will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Box Dimensions and Minimum Box Dimensions -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <!-- Box Dimensions -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-4">Box Dimensions</h2>
                <div class="space-y-4">
                    <div>
                        <label for="boxWidth" class="block text-sm font-medium">Width (inches)</label>
                        <input type="number" id="boxWidth" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm" value="12" min="6" step="0.5" onchange="updateBoxDimensions()">
                    </div>
                    <div>
                        <label for="boxHeight" class="block text-sm font-medium">Height (inches)</label>
                        <input type="number" id="boxHeight" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm" value="12" min="6" step="0.5" onchange="updateBoxDimensions()">
                    </div>
                    <div>
                        <label for="boxDepth" class="block text-sm font-medium">Depth (inches)</label>
                        <input type="number" id="boxDepth" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm" value="4" min="2" step="0.5" onchange="updateBoxDimensions()">
                    </div>
                </div>
            </div>
            
            <!-- Minimum Box Dimensions -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-semibold mb-4">Minimum Box Dimensions</h2>
                <pre id="result" class="text-lg">Add pulls to calculate minimum pull box size.</pre>
                <div id="necWarning" class="warning">
                    <strong>Warning:</strong> The distance between raceway entries enclosing the same conductor shall not be less than six times the metric designator (trade size) of the larger raceway (NEC requirement). Please verify compliance.
                </div>
            </div>
        </div>

        <!-- Debug Window Toggle -->
        <div class="bg-white p-4 rounded-lg shadow-md mb-4">
            <label class="flex items-center space-x-2">
                <input type="checkbox" id="toggleDebug">
                <span>Show Debug Window</span>
            </label>
        </div>

        <!-- Debug Window -->
        <div class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Debug Window</h2>
            <pre id="debug" class="bg-gray-100 p-4 rounded h-64 overflow-y-auto"></pre>
        </div>
    </div>

    <script>
        let pulls = [];
        let pullCounter = 1;
        
        // Box dimensions in inches (converted to pixels for display)
        let currentBoxDimensions = {
            width: 12,
            height: 12,
            depth: 4
        };
        let minimumBoxDimensions = {
            width: 0,
            height: 0,
            depth: 0
        };
        const PIXELS_PER_INCH = 25; // Scale factor for visualization
        
        // Three.js variables
        let scene, camera, renderer, controls;
        let pullBox3D;
        let pullCurves3D = [];
        let pullHoles3D = []; // Store holes in the box
        let is3DMode = true; // Always start in 3D mode
        let isOrthogonalView = false;
        let isRotateMode = false; // false = drag points, true = rotate cube
        let isWireframeMode = false;
        let raycaster, mouse;
        let draggedPoint3D = null;
        let pullEndpoints3D = [];
        let hoveredPoint = null;

        // Hide debug window and NEC warning on page load
        window.onload = function() {
            const debugDiv = document.getElementById('debug').parentElement;
            const necWarning = document.getElementById('necWarning');
            debugDiv.style.display = 'none'; // Hide by default
            necWarning.style.display = 'none'; // Hide NEC warning by default
            toggleConductorSize(); // Initialize conductor size visibility
            
            // Load pulls from localStorage
            loadPullsFromStorage();
            
            updatePullsTable(); // Ensure table is updated on load
            
            // Add view toggle button listener
            document.getElementById('toggleView').addEventListener('click', toggleViewMode);
            document.getElementById('toggleInteraction').addEventListener('click', toggleInteractionMode);
            document.getElementById('toggleWireframe').addEventListener('click', toggleWireframeMode);
        };
        
        // Save pulls and box dimensions to localStorage
        function savePullsToStorage() {
            localStorage.setItem('pullBoxPulls', JSON.stringify(pulls));
            localStorage.setItem('pullCounter', pullCounter.toString());
            localStorage.setItem('boxDimensions', JSON.stringify(currentBoxDimensions));
        }
        
        // Load pulls and box dimensions from localStorage
        function loadPullsFromStorage() {
            const savedPulls = localStorage.getItem('pullBoxPulls');
            const savedCounter = localStorage.getItem('pullCounter');
            const savedDimensions = localStorage.getItem('boxDimensions');
            
            // Load box dimensions
            if (savedDimensions) {
                try {
                    const dimensions = JSON.parse(savedDimensions);
                    currentBoxDimensions = dimensions;
                    // Update the input fields
                    document.getElementById('boxWidth').value = dimensions.width;
                    document.getElementById('boxHeight').value = dimensions.height;
                    document.getElementById('boxDepth').value = dimensions.depth;
                    
                    // Recreate the 3D box with loaded dimensions
                    if (scene) {
                        createPullBox3D();
                        
                        // Adjust camera position based on loaded box size
                        const maxDim = Math.max(dimensions.width * PIXELS_PER_INCH, dimensions.height * PIXELS_PER_INCH);
                        if (!isOrthogonalView) {
                            camera.position.set(0, 0, maxDim * 1.2);
                            camera.lookAt(0, 0, 0);
                        }
                    }
                } catch (e) {
                    console.error('Error loading box dimensions from storage:', e);
                }
            }
            
            // Load pulls
            if (savedPulls) {
                try {
                    pulls = JSON.parse(savedPulls);
                    if (savedCounter) {
                        pullCounter = parseInt(savedCounter);
                    }
                    
                    // Recreate 3D visualization with loaded pulls
                    if (pulls.length > 0) {
                        calculatePullBox();
                        if (is3DMode) {
                            update3DPulls();
                        }
                    }
                } catch (e) {
                    console.error('Error loading pulls from storage:', e);
                    pulls = [];
                    pullCounter = 1;
                }
            }
        }
        
        // Clear all pulls
        function clearAllPulls() {
            if (pulls.length > 0 && confirm('Are you sure you want to clear all pulls?')) {
                pulls = [];
                pullCounter = 1;
                localStorage.removeItem('pullBoxPulls');
                localStorage.removeItem('pullCounter');
                // Note: We keep box dimensions in localStorage even when clearing pulls
                updatePullsTable();
                calculatePullBox();
                if (is3DMode) {
                    update3DPulls();
                }
            }
        }
        
        // Toggle between front and orthogonal views
        function toggleViewMode() {
            isOrthogonalView = !isOrthogonalView;
            const button = document.getElementById('toggleView');
            
            if (isOrthogonalView) {
                // Switch to orthogonal view (isometric)
                const maxDim = Math.max(currentBoxDimensions.width, currentBoxDimensions.height) * PIXELS_PER_INCH;
                camera.position.set(maxDim * 1.5, maxDim * 1.2, maxDim * 1.5);
                camera.lookAt(0, 0, 0);
                button.textContent = 'Switch to Front View';
            } else {
                // Switch to front view
                const maxDim = Math.max(currentBoxDimensions.width, currentBoxDimensions.height) * PIXELS_PER_INCH;
                camera.position.set(0, 0, maxDim * 1.2);
                camera.lookAt(0, 0, 0);
                button.textContent = 'Switch to Orthogonal View';
            }
        }
        
        // Toggle between drag points and rotate cube modes
        function toggleInteractionMode() {
            isRotateMode = !isRotateMode;
            const button = document.getElementById('toggleInteraction');
            controls.enabled = isRotateMode;
            
            if (isRotateMode) {
                button.textContent = 'Switch to Drag Points Mode';
                button.classList.replace('bg-green-600', 'bg-purple-600');
                button.classList.replace('hover:bg-green-700', 'hover:bg-purple-700');
            } else {
                button.textContent = 'Switch to Rotate Mode';
                button.classList.replace('bg-purple-600', 'bg-green-600');
                button.classList.replace('hover:bg-purple-700', 'hover:bg-green-700');
            }
        }
        
        // Toggle between solid and wireframe modes
        function toggleWireframeMode() {
            isWireframeMode = !isWireframeMode;
            const button = document.getElementById('toggleWireframe');
            
            if (isWireframeMode) {
                button.textContent = 'Switch to Solid';
            } else {
                button.textContent = 'Switch to Wireframe';
            }
            
            // Recreate the box with the new mode
            createPullBox3D();
        }

        // Update box dimensions
        function updateBoxDimensions() {
            const width = parseFloat(document.getElementById('boxWidth').value);
            const height = parseFloat(document.getElementById('boxHeight').value);
            const depth = parseFloat(document.getElementById('boxDepth').value);
            
            if (width > 0 && height > 0 && depth > 0) {
                currentBoxDimensions.width = width;
                currentBoxDimensions.height = height;
                currentBoxDimensions.depth = depth;
                
                // Save to localStorage
                savePullsToStorage();
                
                // Recreate the 3D box with new dimensions
                createPullBox3D();
                // Update all pulls to match new box
                update3DPulls();
                
                // Adjust camera position based on new box size
                const maxDim = Math.max(width * PIXELS_PER_INCH, height * PIXELS_PER_INCH);
                if (!isOrthogonalView) {
                    camera.position.set(0, 0, maxDim * 1.2);
                    camera.lookAt(0, 0, 0);
                }
                
                // Check if new dimensions meet minimum requirements
                checkBoxSizeCompliance();
            }
        }
        
        // Toggle conductor size dropdown and label visibility
        function toggleConductorSize() {
            const entrySide = document.getElementById('entrySide').value;
            const exitSide = document.getElementById('exitSide').value;
            const conductorSizeContainer = document.getElementById('conductorSizeContainer');
            const conductorSizeSelect = document.getElementById('conductorSize');
            if (entrySide === 'rear' || exitSide === 'rear') {
                conductorSizeContainer.classList.remove('hidden');
                conductorSizeSelect.selectedIndex = -1; // No default selection
            } else {
                conductorSizeContainer.classList.add('hidden');
                conductorSizeSelect.value = '16'; // Default to 16 AWG if not relevant
            }
        }

        // p5.js Setup
        function setup() {
            // Initialize Three.js and display it immediately
            initThreeJS();
            document.getElementById('canvas-holder').innerHTML = '';
            document.getElementById('canvas-holder').appendChild(renderer.domElement);
            is3DMode = true;
            animate3D();
        }
        
        // Three.js initialization
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            scene.fog = new THREE.Fog(0xf0f0f0, 500, 1500);
            
            camera = new THREE.PerspectiveCamera(75, 500 / 375, 0.1, 1000);
            // Position camera based on current box size (which may have been loaded from localStorage)
            const maxDim = Math.max(currentBoxDimensions.width * PIXELS_PER_INCH, currentBoxDimensions.height * PIXELS_PER_INCH);
            camera.position.set(0, 0, maxDim * 1.2);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(500, 375);
            renderer.shadowMap.enabled = true;
            
            // Add lights for better metal appearance
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(200, 300, 200);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 1000;
            directionalLight.shadow.camera.left = -500;
            directionalLight.shadow.camera.right = 500;
            directionalLight.shadow.camera.top = 500;
            directionalLight.shadow.camera.bottom = -500;
            scene.add(directionalLight);
            
            // Add a second light from the opposite side for better definition
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-200, 200, -100);
            scene.add(directionalLight2);
            
            // Add a point light for highlights
            const pointLight = new THREE.PointLight(0xffffff, 0.2);
            pointLight.position.set(0, 400, 0);
            scene.add(pointLight);
            
            // Add orbit controls but disable them by default
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enabled = false; // Disable mouse rotation by default
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Set up raycaster for 3D mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Create pull box
            createPullBox3D();
            
            // Add event listeners for 3D dragging
            renderer.domElement.addEventListener('mousedown', on3DMouseDown, false);
            renderer.domElement.addEventListener('mousemove', on3DMouseMove, false);
            renderer.domElement.addEventListener('mouseup', on3DMouseUp, false);
        }
        
        function createPullBox3D() {
            // Remove existing box if any
            if (pullBox3D) {
                scene.remove(pullBox3D);
            }
            
            // Convert inches to pixels for display
            const boxWidth = currentBoxDimensions.width * PIXELS_PER_INCH;
            const boxHeight = currentBoxDimensions.height * PIXELS_PER_INCH;
            const boxDepth = currentBoxDimensions.depth * PIXELS_PER_INCH;
            const wallThickness = 0.125 * PIXELS_PER_INCH; // 1/8 inch wall thickness
            
            // Create a group for the box
            pullBox3D = new THREE.Group();
            
            if (isWireframeMode) {
                // Create wireframe box (open front)
                const hw = boxWidth/2, hh = boxHeight/2, hd = boxDepth/2;
                
                // Create edges using LineSegments for the open box
                const edges = [];
                
                // Back rectangle
                edges.push(-hw, -hh, -hd, hw, -hh, -hd);
                edges.push(hw, -hh, -hd, hw, hh, -hd);
                edges.push(hw, hh, -hd, -hw, hh, -hd);
                edges.push(-hw, hh, -hd, -hw, -hh, -hd);
                
                // Front edges (open face) - just the outline
                edges.push(-hw, -hh, hd, hw, -hh, hd);
                edges.push(hw, -hh, hd, hw, hh, hd);
                edges.push(hw, hh, hd, -hw, hh, hd);
                edges.push(-hw, hh, hd, -hw, -hh, hd);
                
                // Connecting edges
                edges.push(-hw, -hh, -hd, -hw, -hh, hd);
                edges.push(hw, -hh, -hd, hw, -hh, hd);
                edges.push(hw, hh, -hd, hw, hh, hd);
                edges.push(-hw, hh, -hd, -hw, hh, hd);
                
                const edgeGeometry = new THREE.BufferGeometry();
                edgeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(edges, 3));
                
                const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                const wireframeLines = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                pullBox3D.add(wireframeLines);
                
                scene.add(pullBox3D);
                addLabels3D();
                return;
            }
            
            // Metal material for the walls
            const metalMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x808080,
                metalness: 0.7,
                roughness: 0.3,
                side: THREE.DoubleSide
            });
            
            // Create individual walls (no front wall)
            // Back wall
            const backWallGeometry = new THREE.BoxGeometry(boxWidth, boxHeight, wallThickness);
            const backWall = new THREE.Mesh(backWallGeometry, metalMaterial);
            backWall.position.z = -boxDepth/2 + wallThickness/2;
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            pullBox3D.add(backWall);
            
            // Left wall
            const leftWallGeometry = new THREE.BoxGeometry(wallThickness, boxHeight, boxDepth);
            const leftWall = new THREE.Mesh(leftWallGeometry, metalMaterial);
            leftWall.position.x = -boxWidth/2 + wallThickness/2;
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            pullBox3D.add(leftWall);
            
            // Right wall
            const rightWallGeometry = new THREE.BoxGeometry(wallThickness, boxHeight, boxDepth);
            const rightWall = new THREE.Mesh(rightWallGeometry, metalMaterial);
            rightWall.position.x = boxWidth/2 - wallThickness/2;
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            pullBox3D.add(rightWall);
            
            // Top wall
            const topWallGeometry = new THREE.BoxGeometry(boxWidth, wallThickness, boxDepth);
            const topWall = new THREE.Mesh(topWallGeometry, metalMaterial);
            topWall.position.y = boxHeight/2 - wallThickness/2;
            topWall.castShadow = true;
            topWall.receiveShadow = true;
            pullBox3D.add(topWall);
            
            // Bottom wall
            const bottomWallGeometry = new THREE.BoxGeometry(boxWidth, wallThickness, boxDepth);
            const bottomWall = new THREE.Mesh(bottomWallGeometry, metalMaterial);
            bottomWall.position.y = -boxHeight/2 + wallThickness/2;
            bottomWall.castShadow = true;
            bottomWall.receiveShadow = true;
            pullBox3D.add(bottomWall);
            
            // Add edge lines for better definition
            const hw = boxWidth/2, hh = boxHeight/2, hd = boxDepth/2;
            
            // Create edges using LineSegments for the open box
            const edges = [];
            
            // Back rectangle
            edges.push(-hw, -hh, -hd, hw, -hh, -hd);
            edges.push(hw, -hh, -hd, hw, hh, -hd);
            edges.push(hw, hh, -hd, -hw, hh, -hd);
            edges.push(-hw, hh, -hd, -hw, -hh, -hd);
            
            // Front edges (open face)
            edges.push(-hw, -hh, hd, hw, -hh, hd);
            edges.push(hw, -hh, hd, hw, hh, hd);
            edges.push(hw, hh, hd, -hw, hh, hd);
            edges.push(-hw, hh, hd, -hw, -hh, hd);
            
            // Connecting edges
            edges.push(-hw, -hh, -hd, -hw, -hh, hd);
            edges.push(hw, -hh, -hd, hw, -hh, hd);
            edges.push(hw, hh, -hd, hw, hh, hd);
            edges.push(-hw, hh, -hd, -hw, hh, hd);
            
            const edgeGeometry = new THREE.BufferGeometry();
            edgeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(edges, 3));
            
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x404040, linewidth: 2 });
            const edgeLines = new THREE.LineSegments(edgeGeometry, edgeMaterial);
            pullBox3D.add(edgeLines);
            
            scene.add(pullBox3D);
            
            // Add labels
            addLabels3D();
        }
        
        function addLabels3D() {
            // Create text labels using canvas
            function createTextSprite(text, color = '#000000') {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 128;
                
                context.fillStyle = 'rgba(255, 255, 255, 0.8)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = 'Bold 48px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 128, 64);
                
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    depthTest: false,
                    depthWrite: false
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(40, 20, 1);
                
                return sprite;
            }
            
            // Get current box dimensions
            const boxWidth = currentBoxDimensions.width * PIXELS_PER_INCH;
            const boxHeight = currentBoxDimensions.height * PIXELS_PER_INCH;
            const boxDepth = currentBoxDimensions.depth * PIXELS_PER_INCH;
            
            // Add labels for each side with positions based on box dimensions
            const leftLabel = createTextSprite('LEFT');
            leftLabel.position.set(-boxWidth/2 - 30, 0, 0);
            pullBox3D.add(leftLabel);
            
            const rightLabel = createTextSprite('RIGHT');
            rightLabel.position.set(boxWidth/2 + 30, 0, 0);
            pullBox3D.add(rightLabel);
            
            const topLabel = createTextSprite('TOP');
            topLabel.position.set(0, boxHeight/2 + 20, 0);
            pullBox3D.add(topLabel);
            
            const bottomLabel = createTextSprite('BOTTOM');
            bottomLabel.position.set(0, -boxHeight/2 - 20, 0);
            pullBox3D.add(bottomLabel);
            
            const rearLabel = createTextSprite('REAR');
            rearLabel.position.set(0, 0, -boxDepth/2 - 20);
            pullBox3D.add(rearLabel);
        }

        function draw() {
            // p5.js draw is not needed anymore since we're using Three.js
            // We can keep this empty or use it for other purposes if needed
        }
        
        function animate3D() {
            if (!is3DMode) return;
            
            requestAnimationFrame(animate3D);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function update3DPulls() {
            // Remove existing pull curves
            pullCurves3D.forEach(obj => scene.remove(obj));
            pullCurves3D = [];
            pullEndpoints3D = [];
            
            // Remove existing holes
            pullHoles3D.forEach(hole => {
                if (hole.parent) hole.parent.remove(hole);
            });
            pullHoles3D = [];
            
            // Add new pull curves
            pulls.forEach((pull, index) => {
                draw3DPull(pull, index);
            });
        }
        
        // Create a hole appearance in the box wall
        function createHole(position, side, conduitSize) {
            const holeRadius = (conduitSize / 2) * PIXELS_PER_INCH; // Use actual conduit size
            const wallThickness = 0.125 * PIXELS_PER_INCH; // 1/8 inch wall thickness
            const cylinderLength = wallThickness + (0.5 * PIXELS_PER_INCH); // Extend 0.25 inch on each side
            
            // Create a group for the hole components
            const holeGroup = new THREE.Group();
            
            // Create hollow cylinder that passes through the wall
            const cylinderGeometry = new THREE.CylinderGeometry(
                holeRadius, // top radius
                holeRadius, // bottom radius
                cylinderLength, // height (length)
                32, // radial segments
                1, // height segments
                true // open ended - this makes it hollow
            );
            
            // Metal material for the cylinder
            const cylinderMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x404040,
                metalness: 0.8,
                roughness: 0.3,
                side: THREE.DoubleSide // Render both sides
            });
            
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.castShadow = true;
            cylinder.receiveShadow = true;
            
            // Create center fill cylinder matching background
            const fillRadius = holeRadius * 0.98; // Slightly smaller to show ring edge
            const fillGeometry = new THREE.CylinderGeometry(
                fillRadius,
                fillRadius,
                cylinderLength, // Same length as outer cylinder
                32,
                1,
                false // closed ended
            );
            const fillMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xf0f0f0 // Match scene background color
            });
            const centerFill = new THREE.Mesh(fillGeometry, fillMaterial);
            
            // Add components to group
            holeGroup.add(cylinder);
            holeGroup.add(centerFill);
            
            // Position the group
            holeGroup.position.copy(position);
            
            // Orient both cylinder and fill based on which wall it's on
            switch(side) {
                case 'left':
                case 'right':
                    cylinder.rotation.z = Math.PI / 2;
                    centerFill.rotation.z = Math.PI / 2;
                    break;
                case 'top':
                case 'bottom':
                    // Already in correct orientation (vertical)
                    break;
                case 'rear':
                    cylinder.rotation.x = Math.PI / 2;
                    centerFill.rotation.x = Math.PI / 2;
                    break;
            }
            
            return holeGroup;
        }
        
        function draw3DPull(pull, index) {
            const boxWidth = currentBoxDimensions.width * PIXELS_PER_INCH;
            const boxHeight = currentBoxDimensions.height * PIXELS_PER_INCH;
            const boxDepth = currentBoxDimensions.depth * PIXELS_PER_INCH;
            
            // Get 3D positions for entry and exit points
            const entryPos = pull.customEntryPoint3D || get3DPosition(pull.entrySide, boxWidth, boxHeight, boxDepth);
            const exitPos = pull.customExitPoint3D || get3DPosition(pull.exitSide, boxWidth, boxHeight, boxDepth);
            
            // Create curve
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(entryPos.x, entryPos.y, entryPos.z),
                new THREE.Vector3((entryPos.x + exitPos.x) / 2, (entryPos.y + exitPos.y) / 2, (entryPos.z + exitPos.z) / 2),
                new THREE.Vector3(exitPos.x, exitPos.y, exitPos.z)
            ]);
            
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 5 });
            const curveObject = new THREE.Line(geometry, material);
            
            // Create a tube geometry for better visibility (like a wire/conduit)
            const tubeGeometry = new THREE.TubeGeometry(curve, 50, 3, 8, false);
            const tubeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0066ff, 
                emissive: 0x0044ff,
                emissiveIntensity: 0.2,
                metalness: 0.5,
                roughness: 0.3
            });
            const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tubeMesh.castShadow = true;
            tubeMesh.receiveShadow = true;
            
            scene.add(tubeMesh);
            pullCurves3D.push(tubeMesh);
            
            // Create holes at entry and exit points
            const entryHole = createHole(new THREE.Vector3(entryPos.x, entryPos.y, entryPos.z), pull.entrySide, pull.conduitSize);
            pullBox3D.add(entryHole);
            pullHoles3D.push(entryHole);
            pull.entryHole = entryHole;
            
            const exitHole = createHole(new THREE.Vector3(exitPos.x, exitPos.y, exitPos.z), pull.exitSide, pull.conduitSize);
            pullBox3D.add(exitHole);
            pullHoles3D.push(exitHole);
            pull.exitHole = exitHole;
            
            // Add draggable spheres at entry and exit points (make them slightly larger for easier grabbing)
            const sphereGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0066ff,
                emissive: 0x0044ff,
                emissiveIntensity: 0.3,
                metalness: 0.5,
                roughness: 0.3
            });
            
            // Create invisible larger sphere for easier interaction
            const interactionGeometry = new THREE.SphereGeometry(15, 16, 16);
            const interactionMaterial = new THREE.MeshBasicMaterial({ 
                visible: false 
            });
            
            const entrySphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            entrySphere.position.set(entryPos.x, entryPos.y, entryPos.z);
            const entryInteraction = new THREE.Mesh(interactionGeometry, interactionMaterial);
            entryInteraction.position.copy(entrySphere.position);
            entryInteraction.userData = { type: 'entry', pullIndex: index, pull: pull, visualSphere: entrySphere };
            entrySphere.userData = { type: 'entry', pullIndex: index, pull: pull };
            
            scene.add(entrySphere);
            scene.add(entryInteraction);
            pullCurves3D.push(entrySphere);
            pullCurves3D.push(entryInteraction);
            pullEndpoints3D.push(entryInteraction);
            
            const exitSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            exitSphere.position.set(exitPos.x, exitPos.y, exitPos.z);
            const exitInteraction = new THREE.Mesh(interactionGeometry, interactionMaterial);
            exitInteraction.position.copy(exitSphere.position);
            exitInteraction.userData = { type: 'exit', pullIndex: index, pull: pull, visualSphere: exitSphere };
            exitSphere.userData = { type: 'exit', pullIndex: index, pull: pull };
            
            scene.add(exitSphere);
            scene.add(exitInteraction);
            pullCurves3D.push(exitSphere);
            pullCurves3D.push(exitInteraction);
            pullEndpoints3D.push(exitInteraction);
            
            // Add arrow at exit point
            const arrowGeometry = new THREE.ConeGeometry(8, 20, 8);
            const arrowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0066ff,
                emissive: 0x0044ff,
                emissiveIntensity: 0.3,
                metalness: 0.5,
                roughness: 0.3
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.set(exitPos.x, exitPos.y, exitPos.z);
            arrow.castShadow = true;
            
            // Orient arrow based on exit side
            if (pull.exitSide === 'left') arrow.rotation.z = Math.PI / 2;
            else if (pull.exitSide === 'right') arrow.rotation.z = -Math.PI / 2;
            else if (pull.exitSide === 'top') arrow.rotation.z = 0;
            else if (pull.exitSide === 'bottom') arrow.rotation.z = Math.PI;
            else if (pull.exitSide === 'rear') arrow.rotation.x = -Math.PI / 2;
            
            scene.add(arrow);
            pullCurves3D.push(arrow);
        }
        
        function get3DPosition(side, boxWidth, boxHeight, boxDepth) {
            switch (side) {
                case 'left': return { x: -boxWidth / 2, y: 0, z: 0 };
                case 'right': return { x: boxWidth / 2, y: 0, z: 0 };
                case 'top': return { x: 0, y: boxHeight / 2, z: 0 };
                case 'bottom': return { x: 0, y: -boxHeight / 2, z: 0 };
                case 'rear': return { x: 0, y: 0, z: -boxDepth / 2 };
                default: return { x: 0, y: 0, z: 0 };
            }
        }

        // Removed 2D drawing functions - now using only 3D

        // Removed 2D mouse functions - now using only 3D interaction

        // Pull Management
        function addPull() {
            const entrySide = document.getElementById('entrySide').value;
            const exitSide = document.getElementById('exitSide').value;
            const conduitSize = parseFloat(document.getElementById('conduitSize').value);
            const conductorSizeSelect = document.getElementById('conductorSize');
            const conductorSize = (entrySide === 'rear' || exitSide === 'rear') ? conductorSizeSelect.value : '16';

            if (!conduitSize || conduitSize <= 0) {
                alert('Please enter a valid conduit size.');
                return;
            }

            // Validate conductor size for rear pulls with a dialogue box
            if ((entrySide === 'rear' || exitSide === 'rear') && (!conductorSize || conductorSize === '')) {
                console.log('Validation triggered - entrySide:', entrySide, 'exitSide:', exitSide, 'conductorSize:', conductorSize, 'selectedIndex:', conductorSizeSelect.selectedIndex);
                if (!confirm('Please select a conductor size for pulls to or from the rear. Click OK to return and choose a size, or Cancel to abort.')) {
                    return; // Cancel aborts the action
                }
                return; // Return to prompt user to select a size
            }

            let pull = {
                id: pullCounter,
                entrySide,
                exitSide,
                conduitSize,
                conductorSize,
                customEntryPoint3D: null,
                customExitPoint3D: null
            };

            // For U-pulls in 3D, set default points with an offset
            if (entrySide === exitSide) {
                const offset = 0.8 * PIXELS_PER_INCH; // 0.8 inch offset
                const boxWidth = currentBoxDimensions.width * PIXELS_PER_INCH;
                const boxHeight = currentBoxDimensions.height * PIXELS_PER_INCH;
                const boxDepth = currentBoxDimensions.depth * PIXELS_PER_INCH;
                
                switch (entrySide) {
                    case 'left':
                        pull.customEntryPoint3D = { x: -boxWidth/2, y: -offset/2, z: 0 };
                        pull.customExitPoint3D = { x: -boxWidth/2, y: offset/2, z: 0 };
                        break;
                    case 'right':
                        pull.customEntryPoint3D = { x: boxWidth/2, y: -offset/2, z: 0 };
                        pull.customExitPoint3D = { x: boxWidth/2, y: offset/2, z: 0 };
                        break;
                    case 'top':
                        pull.customEntryPoint3D = { x: -offset/2, y: boxHeight/2, z: 0 };
                        pull.customExitPoint3D = { x: offset/2, y: boxHeight/2, z: 0 };
                        break;
                    case 'bottom':
                        pull.customEntryPoint3D = { x: -offset/2, y: -boxHeight/2, z: 0 };
                        pull.customExitPoint3D = { x: offset/2, y: -boxHeight/2, z: 0 };
                        break;
                    case 'rear':
                        pull.customEntryPoint3D = { x: -offset/2, y: 0, z: -boxDepth/2 };
                        pull.customExitPoint3D = { x: offset/2, y: 0, z: -boxDepth/2 };
                        break;
                }
            }

            pulls.push(pull);
            savePullsToStorage(); // Save to localStorage
            updatePullsTable();
            calculatePullBox();
            // Update 3D visualization if in 3D mode
            if (is3DMode) {
                update3DPulls();
            }
            pullCounter++;
        }

        function removePull(id) {
            pulls = pulls.filter(pull => pull.id !== id);
            savePullsToStorage(); // Save to localStorage
            updatePullsTable();
            calculatePullBox();
            // Update 3D visualization if in 3D mode
            if (is3DMode) {
                update3DPulls();
            }
        }

        function updatePullsTable() {
            const tbody = document.getElementById('pullsBody');
            const pullsList = document.querySelector('.pulls-list');
            const hasRear = pulls.some(pull => pull.entrySide === 'rear' || pull.exitSide === 'rear');
            tbody.innerHTML = '';
            pullsList.innerHTML = '';
            pulls.forEach(pull => {
                // Mobile stacked view (default)
                const item = document.createElement('div');
                item.className = 'pull-item';
                if (hasRear) item.classList.add('has-rear');
                item.innerHTML = `
                    <div><span class="font-medium">Pull #:</span> <span>${pull.id}</span></div>
                    <div><span class="font-medium">Entry Side:</span> <span>${pull.entrySide}</span></div>
                    <div><span class="font-medium">Exit Side:</span> <span>${pull.exitSide}</span></div>
                    <div><span class="font-medium">Conduit Size (in):</span> <span>${fractionToString(pull.conduitSize)}"</span></div>
                    <div class="conductor-mobile"><span class="font-medium">Conductor Size:</span> <span>${pull.entrySide === 'rear' || pull.exitSide === 'rear' ? pull.conductorSize : '-'}</span></div>
                    <div><span class="font-medium">Action:</span> <span><button onclick="removePull(${pull.id})" class="text-red-600 hover:text-red-800">Remove</button></span></div>
                `;
                pullsList.appendChild(item);

                // Desktop table view
                const row = document.createElement('tr');
                row.className = 'pull-row';
                row.innerHTML = `
                    <td class="border p-2">${pull.id}</td>
                    <td class="border p-2">${pull.entrySide}</td>
                    <td class="border p-2">${pull.exitSide}</td>
                    <td class="border p-2">${fractionToString(pull.conduitSize)}"</td>
                    <td class="border p-2">${pull.entrySide === 'rear' || pull.exitSide === 'rear' ? pull.conductorSize : '-'}</td>
                    <td class="border p-2"><button onclick="removePull(${pull.id})" class="text-red-600 hover:text-red-800">Remove</button></td>
                `;
                tbody.appendChild(row);
            });
        }

        // Convert decimal to fraction string for display
        function fractionToString(decimal) {
            const fractions = {
                0.5: '1/2',
                0.75: '3/4',
                1: '1',
                1.25: '1-1/4',
                1.5: '1-1/2',
                2: '2',
                2.5: '2-1/2',
                3: '3',
                3.5: '3-1/2',
                4: '4',
                5: '5',
                6: '6'
            };
            return fractions[decimal] || decimal.toString();
        }

        // Calculation Logic
        function calculatePullBox() {
            if (pulls.length === 0) {
                document.getElementById('result').textContent = 'Add pulls to calculate minimum pull box size.';
                document.getElementById('debug').textContent = '';
                return;
            }

            let debugLog = '';

            // Step 1: Horizontal Straight Pulls
            const hStraightPulls = pulls.filter(p => 
                (p.entrySide === 'left' && p.exitSide === 'right') || 
                (p.entrySide === 'right' && p.exitSide === 'left')
            );
            const maxHStraight = Math.max(...hStraightPulls.map(p => p.conduitSize), 0);
            const minHStraightCalc = maxHStraight * 8;
            debugLog += `Step 1: Minimum horizontal straight pull calc = ${maxHStraight} x 8 = ${minHStraightCalc} in\n`;

            // Step 2: Vertical Straight Pulls
            const vStraightPulls = pulls.filter(p => 
                (p.entrySide === 'top' && p.exitSide === 'bottom') || 
                (p.entrySide === 'bottom' && p.exitSide === 'top')
            );
            const maxVStraight = Math.max(...vStraightPulls.map(p => p.conduitSize), 0);
            const minVStraightCalc = maxVStraight * 8;
            debugLog += `Step 2: Minimum vertical straight pull calc = ${maxVStraight} x 8 = ${minVStraightCalc} in\n`;

            // Helper function for angle/u-pull calculations
            function calculateSide(side, validPulls) {
                const sidePulls = pulls.filter(p => validPulls(p, side)).map((p, i) => ({ ...p, originalIndex: i }));
                if (sidePulls.length === 0) return 0;

                const maxPull = sidePulls.reduce((max, p) => p.conduitSize > max.conduitSize ? p : max, sidePulls[0]);
                const maxSize = maxPull.conduitSize;
                let additionalConduits = [];

                sidePulls.forEach(p => {
                    if (p !== maxPull) {
                        additionalConduits.push(p.conduitSize);
                    }
                    // For U-pulls, count the other side if it's not the max pull
                    if (p.entrySide === p.exitSide && p.entrySide === side && p !== maxPull) {
                        additionalConduits.push(p.conduitSize);
                    }
                });

                // If max pull is a U-pull, add it once more
                if (maxPull.entrySide === maxPull.exitSide && maxPull.entrySide === side) {
                    additionalConduits.push(maxPull.conduitSize);
                }

                const calc = 6 * maxSize + additionalConduits.reduce((sum, size) => sum + size, 0);
                debugLog += `Relevant pulls for ${side}: ${sidePulls.map(p => `Pull ${p.id} (${fractionToString(p.conduitSize)}")`).join(', ')}\n`;
                debugLog += `Largest pull: Pull ${maxPull.id} (${fractionToString(maxSize)}"), U-pull: ${maxPull.entrySide === maxPull.exitSide}\n`;
                debugLog += `Calculation: (6 x ${maxSize}) + ${additionalConduits.map(size => fractionToString(size)).join(' + ')} = ${calc} in\n`;
                return calc;
            }

            // Step 3: Left Side Angle/U-Pulls
            const leftPullsFilter = (p, side) => 
                (p.entrySide === side && p.exitSide !== 'right') || 
                (p.exitSide === side && p.entrySide !== 'right') || 
                (p.entrySide === side && p.exitSide === side);
            const minLeftCalc = calculateSide('left', leftPullsFilter);
            debugLog += `Step 3: Minimum left side angle/u-pull calc = ${minLeftCalc} in\n`;

            // Step 4: Right Side Angle/U-Pulls
            const rightPullsFilter = (p, side) => 
                (p.entrySide === side && p.exitSide !== 'left') || 
                (p.exitSide === side && p.entrySide !== 'left') || 
                (p.entrySide === side && p.exitSide === side);
            const minRightCalc = calculateSide('right', rightPullsFilter);
            debugLog += `Step 4: Minimum right side angle/u-pull calc = ${minRightCalc} in\n`;

            // Step 5: Top Side Angle/U-Pulls
            const topPullsFilter = (p, side) => 
                (p.entrySide === side && p.exitSide !== 'bottom') || 
                (p.exitSide === side && p.entrySide !== 'bottom') || 
                (p.entrySide === side && p.exitSide === side);
            const minTopCalc = calculateSide('top', topPullsFilter);
            debugLog += `Step 5: Minimum top side angle/u-pull calc = ${minTopCalc} in\n`;

            // Step 6: Bottom Side Angle/U-Pulls
            const bottomPullsFilter = (p, side) => 
                (p.entrySide === side && p.exitSide !== 'top') || 
                (p.exitSide === side && p.entrySide !== 'top') || 
                (p.entrySide === side && p.exitSide === side);
            const minBottomCalc = calculateSide('bottom', bottomPullsFilter);
            debugLog += `Step 6: Minimum bottom side angle/u-pull calc = ${minBottomCalc} in\n`;

            // Step 7: Rear Side Depth
            const rearPulls = pulls.filter(p => 
                (p.entrySide === 'rear' && p.exitSide !== 'rear') || 
                (p.exitSide === 'rear' && p.entrySide !== 'rear') || 
                (p.entrySide === 'rear' && p.exitSide === 'rear')
            );
            const conductorDepths = {
                '16': 1.5, '14': 1.5, '12': 1.5, '10': 1.5, '8': 1.5, '6': 1.5,
                '4': 2, '3': 2,
                '2': 2.5,
                '1': 3,
                '1/0': 3.5, '2/0': 3.5,
                '3/0': 4, '4/0': 4,
                '250': 4.5,
                '300': 5, '350': 5,
                '400': 6, '500': 6,
                '600': 8, '750': 8, '900': 8,
                '1000': 10, '1250': 10,
                '1500': 12, '1750': 12, '2000': 12
            };
            const maxDepth = Math.max(...rearPulls.map(p => conductorDepths[p.conductorSize] || 0), 0);
            debugLog += `Step 7: Minimum pull can depth = ${maxDepth} in\n`;

            // Step 8: Minimum Pull Can Width
            const widthCalcs = [minHStraightCalc, minLeftCalc, minRightCalc];
            const minWidth = Math.max(...widthCalcs);
            debugLog += `Step 8: Minimum pull can width\n`;
            debugLog += `  Horizontal: ${minHStraightCalc} in\n`;
            debugLog += `  Left: ${minLeftCalc} in\n`;
            debugLog += `  Right: ${minRightCalc} in\n`;
            debugLog += `  Selected: ${minWidth} in\n`;

            // Step 9: Minimum Pull Can Height
            const heightCalcs = [minVStraightCalc, minTopCalc, minBottomCalc];
            const minHeight = Math.max(...heightCalcs);
            debugLog += `Step 9: Minimum pull can height\n`;
            debugLog += `  Vertical: ${minVStraightCalc} in\n`;
            debugLog += `  Top: ${minTopCalc} in\n`;
            debugLog += `  Bottom: ${minBottomCalc} in\n`;
            debugLog += `  Selected: ${minHeight} in\n`;

            // Step 10: Final Result
            const width = minWidth > 0 ? `${fractionToString(minWidth)}"` : "No Code Minimum";
            const height = minHeight > 0 ? `${fractionToString(minHeight)}"` : "No Code Minimum";
            const depth = maxDepth > 0 ? `${fractionToString(maxDepth)}"` : "No Code Minimum";
            const result = `Width: ${width}\n\nHeight: ${height}\n\nDepth: ${depth}`;
            debugLog += `Step 10: Final pull box size = ${result.replace(/\n/g, ' ')}\n`;

            // Store minimum dimensions for comparison
            minimumBoxDimensions.width = minWidth;
            minimumBoxDimensions.height = minHeight;
            minimumBoxDimensions.depth = maxDepth;

            document.getElementById('result').textContent = result;
            document.getElementById('debug').textContent = debugLog;
            
            // Check if current box meets minimum requirements
            checkBoxSizeCompliance();
        }

        // Function to check if current box meets minimum size requirements
        function checkBoxSizeCompliance() {
            const necWarning = document.getElementById('necWarning');
            const violations = [];
            
            // Check each dimension
            if (minimumBoxDimensions.width > 0 && currentBoxDimensions.width < minimumBoxDimensions.width) {
                violations.push(`Width: ${currentBoxDimensions.width}" < ${fractionToString(minimumBoxDimensions.width)}" minimum`);
            }
            if (minimumBoxDimensions.height > 0 && currentBoxDimensions.height < minimumBoxDimensions.height) {
                violations.push(`Height: ${currentBoxDimensions.height}" < ${fractionToString(minimumBoxDimensions.height)}" minimum`);
            }
            if (minimumBoxDimensions.depth > 0 && currentBoxDimensions.depth < minimumBoxDimensions.depth) {
                violations.push(`Depth: ${currentBoxDimensions.depth}" < ${fractionToString(minimumBoxDimensions.depth)}" minimum`);
            }
            
            // Show warning if any violations exist
            if (violations.length > 0) {
                necWarning.innerHTML = `<strong>Warning:</strong> Current box dimensions do not meet NEC minimum requirements:<br>` + 
                    violations.join('<br>') + 
                    `<br><br>Please increase box dimensions to meet code requirements.<br>` +
                    `<button onclick="setToMinimumDimensions()" class="mt-2 bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700 text-sm">Set to Minimum Dimensions</button>`;
                necWarning.style.display = 'block';
            } else {
                necWarning.style.display = 'none';
            }
        }
        
        // Function to automatically set box dimensions to minimum requirements
        function setToMinimumDimensions() {
            // Update input fields
            if (minimumBoxDimensions.width > 0) {
                document.getElementById('boxWidth').value = minimumBoxDimensions.width;
            }
            if (minimumBoxDimensions.height > 0) {
                document.getElementById('boxHeight').value = minimumBoxDimensions.height;
            }
            if (minimumBoxDimensions.depth > 0) {
                document.getElementById('boxDepth').value = minimumBoxDimensions.depth;
            }
            
            // Apply the changes
            updateBoxDimensions();
        }

        // Toggle debug window visibility
        document.getElementById('toggleDebug').addEventListener('change', function() {
            const debugDiv = document.getElementById('debug').parentElement;
            if (this.checked) {
                debugDiv.style.display = 'block';
            } else {
                debugDiv.style.display = 'none';
            }
        });
        
        // 3D Mouse interaction functions
        function on3DMouseDown(event) {
            if (isRotateMode) return; // Let OrbitControls handle it
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pullEndpoints3D);
            
            if (intersects.length > 0) {
                draggedPoint3D = intersects[0].object;
            }
        }
        
        function on3DMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check for hover when not dragging
            if (!draggedPoint3D && !isRotateMode) {
                const intersects = raycaster.intersectObjects(pullEndpoints3D);
                if (intersects.length > 0) {
                    renderer.domElement.style.cursor = 'pointer';
                    hoveredPoint = intersects[0].object;
                } else {
                    renderer.domElement.style.cursor = isRotateMode ? 'move' : 'default';
                    hoveredPoint = null;
                }
            }
            
            if (!draggedPoint3D || isRotateMode) return;
            
            // Get the side of the wall this point should be constrained to
            const pull = draggedPoint3D.userData.pull;
            const pointType = draggedPoint3D.userData.type;
            const side = pointType === 'entry' ? pull.entrySide : pull.exitSide;
            const visualSphere = draggedPoint3D.userData.visualSphere;
            
            // Create a plane for the wall
            let planeNormal, planeConstant;
            const boxWidth = currentBoxDimensions.width * PIXELS_PER_INCH;
            const boxHeight = currentBoxDimensions.height * PIXELS_PER_INCH;
            const boxDepth = currentBoxDimensions.depth * PIXELS_PER_INCH;
            
            switch (side) {
                case 'left':
                    planeNormal = new THREE.Vector3(1, 0, 0);
                    planeConstant = boxWidth / 2;
                    break;
                case 'right':
                    planeNormal = new THREE.Vector3(-1, 0, 0);
                    planeConstant = boxWidth / 2;
                    break;
                case 'top':
                    planeNormal = new THREE.Vector3(0, -1, 0);
                    planeConstant = boxHeight / 2;
                    break;
                case 'bottom':
                    planeNormal = new THREE.Vector3(0, 1, 0);
                    planeConstant = boxHeight / 2;
                    break;
                case 'rear':
                    planeNormal = new THREE.Vector3(0, 0, 1);
                    planeConstant = boxDepth / 2;
                    break;
            }
            
            const plane = new THREE.Plane(planeNormal, planeConstant);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);
            
            // Constrain the intersection point to the wall bounds
            switch (side) {
                case 'left':
                case 'right':
                    intersection.y = Math.max(-boxHeight/2, Math.min(boxHeight/2, intersection.y));
                    intersection.z = Math.max(-boxDepth/2, Math.min(boxDepth/2, intersection.z));
                    break;
                case 'top':
                case 'bottom':
                    intersection.x = Math.max(-boxWidth/2, Math.min(boxWidth/2, intersection.x));
                    intersection.z = Math.max(-boxDepth/2, Math.min(boxDepth/2, intersection.z));
                    break;
                case 'rear':
                    intersection.x = Math.max(-boxWidth/2, Math.min(boxWidth/2, intersection.x));
                    intersection.y = Math.max(-boxHeight/2, Math.min(boxHeight/2, intersection.y));
                    break;
            }
            
            // Update the sphere positions
            draggedPoint3D.position.copy(intersection);
            if (visualSphere) {
                visualSphere.position.copy(intersection);
            }
            
            // Update the hole position
            const hole = pointType === 'entry' ? pull.entryHole : pull.exitHole;
            if (hole) {
                hole.position.copy(intersection);
            }
            
            // Update the pull's custom point
            if (pointType === 'entry') {
                pull.customEntryPoint3D = { x: intersection.x, y: intersection.y, z: intersection.z };
            } else {
                pull.customExitPoint3D = { x: intersection.x, y: intersection.y, z: intersection.z };
            }
            
            // Redraw pulls (but keep the holes)
            update3DPulls();
        }
        
        function on3DMouseUp(event) {
            if (draggedPoint3D) {
                savePullsToStorage(); // Save when done dragging
            }
            draggedPoint3D = null;
            renderer.domElement.style.cursor = isRotateMode ? 'move' : 'default';
        }
    </script>
</body>
</html>